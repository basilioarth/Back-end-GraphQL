# Resumo da Aula 4 – Login + Middleware de Autenticação Completo

## 1. Mutation de Login Implementada
### Input
```ts
@InputType()
export class LoginInput {
  @Field(() => String) email: string
  @Field(() => String) password: string
}
```

### Output (reaproveita a mesma estrutura do register)
```ts
@ObjectType()
export class LoginOutput {
  @Field(() => String) token: string
  @Field(() => String) refreshToken: string
  @Field(() => UserModel) user: UserModel
}
```

### AuthService – nova função login()
- Busca usuário por e-mail
- Se não existir → “Usuário não cadastrado”
- Compara senha com bcrypt (`comparePassword`)
- Se senha errada → “Senha inválida”
- Se tudo certo → gera access token (15 min) + refresh token (1 dia) e retorna

### Utilitário novo
```ts
// utils/hash.ts
export const comparePassword = async (plain: string, hash: string) => 
  await bcrypt.compare(plain, hash);
```

### Mutation no AuthResolver
```ts
@Mutation(() => LoginOutput)
async login(@Arg("data") data: LoginInput) {
  return this.authService.login(data);
}
```

Teste no Playground funcionou perfeitamente → retorna token + refreshToken + dados do usuário.

## 2. Contexto GraphQL + Verificação de JWT
### Pasta criada: `src/graphql/context/index.ts`
```ts
export type GraphQLContext = {
  user?: string          // id do usuário logado
  token?: string
  req: Request
  res: Response
}

export const buildContext = async ({ req, res }: ExpressContextFunctionArgument): Promise<GraphQLContext> => {
  const authHeader = req.headers.authorization || ""
  let token: string | undefined
  let user: string | undefined

  if (authHeader.startsWith("Bearer ")) {
    token = authHeader.substring(7)
    try {
      const payload = verifyJWT(token)   // nova função criada
      user = payload.id
    } catch {}
  }

  return { user, token, req, res }
}
```

### Nova função no `utils/jwt.ts`:
```ts
export const verifyJWT = (token: string): JWTPayload => {
  const secret = process.env.JWT_SECRET as string
  return jwt.verify(token, secret) as JWTPayload
}
```

Contexto injetado no middleware do Apollo:
```ts
app.use("/graphql", expressMiddleware(server, { context: buildContext }))
```

## 3. Middleware de Autenticação
### Pasta: `src/middlewares/auth.middleware.ts`
```ts
import { MiddlewareFn } from "type-graphql"
import { GraphQLContext } from "../graphql/context"

export const isAuth: MiddlewareFn<GraphQLContext> = ({ context }, next) => {
  if (!context.user) {
    throw new Error("Usuário não autenticado")
  }
  return next()
}
```

Uso no UserResolver:
```ts
@Resolver(() => UserModel)
@UseMiddleware(isAuth)      // protege toda a classe
export class UserResolver { ... }
```

## 4. Testes no Playground
- getUser sem token → “Usuário não autenticado”
- Login → copia o token
- Adiciona header no Playground:
```http
{
  "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6..."
}
```
- getUser com token válido → retorna dados do usuário com sucesso

## Próxima aula (já anunciada)
- Mutation de criar ideia (`createIdea`)
- Criar decorator customizado `@CurrentUser()` para injetar automaticamente o ID/nome do usuário logado em qualquer resolver
- Começar a construir as funcionalidades reais do Mindshare com rotas 100% protegidas

Tudo funcionando: login, JWT válido, contexto populado, middleware de proteção e query protegida!  
Back-end de autenticação do Mindshare já está sólido e seguro!  
Bora pra próxima aula!