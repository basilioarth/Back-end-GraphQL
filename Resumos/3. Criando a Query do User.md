# Resumo da Aula 3 – Servidor no Ar + Teste Completo da Mutation de Cadastro

## O que foi feito para o servidor subir
1. Criado **UserResolver** + **UserService** com uma query simples obrigatória:
```ts
@Query(() => UserModel)
async getUser(@Arg("id") id: string) {
  return this.userService.findUser(id);
}
```
   - Serviço busca usuário por ID no Prisma
   - Se não existir → `throw new Error("Usuário não existe")`

2. Adicionados os dois resolvers no `buildSchema` do index.ts:
```ts
resolvers: [AuthResolver, UserResolver]
```

3. Corrigido erro crítico:
```ts
import "reflect-metadata";  // ← obrigatório no início do index.ts
```

4. Servidor iniciado com sucesso:
```
npm run dev
→ Servidor iniciado na porta 4000
→ Playground agora em http://localhost:4000/graphql
```

## Teste completo da mutation register
Mutation executada no Apollo Sandbox:
```graphql
mutation Register($data: RegisterInput!) {
  register(data: $data) {
    token
    refreshToken
    user {
      id
      name
      email
      password      # (traz o hash para conferência
      createdAt
      updatedAt
    }
  }
}
```

Variables:
```json
{
  "data": {
    "name": "Felipe",
    "email": "felipe@rocketseat.com.br",
    "password": "123456"
  }
}
```

Resultado:
- Usuário criado no SQLite
- Password salvo já **hasheado** (bcrypt)
- Retornado:
  - `token` → JWT válido por 15 minutos
  - `refreshToken` → JWT válido por 1 dia
  - Dados completos do usuário (exceto password em produção)

## Teste da query getUser
```graphql
query GetUser($getUserId: String!) {
  getUser(id: $getUserId) {
    id
    name
    email
    createdAt
  }
}
```
- Passado o `id` retornado no cadastro → usuário retornado corretamente

## Pequenas correções feitas ao vivo
- Injeção manual dos services nos resolvers (ainda sem container de injeção):
```ts
private readonly authService = new AuthService();
private readonly userService = new UserService();
```

## O que vem na próxima aula
- Mutation de **login**
- Middleware de autenticação global
- Criação de **rotas protegidas**
- Decorator customizado `@CurrentUser()` para pegar automaticamente o usuário logado a partir do token nos headers
- Estratégia completa de refresh token

**Tudo funcionando: cadastro com JWT + refresh token + busca de usuário por ID.**  
Back-end do Mindshare já autenticando e persistindo usuários de verdade!  
Bora pra próxima aula!