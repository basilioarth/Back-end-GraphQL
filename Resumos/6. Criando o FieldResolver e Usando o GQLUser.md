# Resumo da Aula 6 – Finalizando CreateIdea + UpdateIdea + Field Resolver

## 1. Mutation createIdea 100% funcional com @GQLUser()
```ts
@Mutation(() => IdeaModel)
@UseMiddleware(isAuth)                 // ← obrigatório
async createIdea(
  @Arg("data") data: CreateIdeaInput,
  @GQLUser() user: User                 // ← injeta automaticamente o usuário logado + buscado no banco
) {
  return this.ideaService.createIdea(data, user.id);
}
```
- Não precisa mais passar authorId no input
- O middleware isAuth garante que o usuário esteja logado antes mesmo de entrar no resolver
- Testado no Playground com Bearer token → ideia criada com author corretamente relacionado

## 2. Field Resolver para popular o relacionamento author
```ts
@FieldResolver(() => UserModel)
async author(@Root() idea: IdeaModel) {
  return this.userService.findUser(idea.authorId);
}
```
- Resolve o problema do author vir null no retorno
- O GraphQL chama automaticamente essa função quando o cliente pede o campo author
- Funciona para qualquer nível de profundidade (author.name, author.email etc.)
- Vantagem extra: pode ser usado para buscar dados de APIs externas, microserviços, etc.

Resultado no Playground:
```graphql
mutation {
  createIdea(data: { title: "Segunda ideia", description: "Olá, essa é a descrição" }) {
    id
    title
    description
    author {
      id
      name
      email
    }
  }
}
```
→ author vem completamente populado

## 3. Mutation updateIdea com ID separado do payload
### Input novo
```ts
@InputType()
class UpdateIdeaInput {
  @Field(() => String, { nullable: true }) title?: string
  @Field(() => String, { nullable: true }) description?: string
}
```

### Resolver final
```ts
@Mutation(() => IdeaModel)
@UseMiddleware(isAuth)
async updateIdea(
  @Arg("ideaId") ideaId: string,
  @Arg("data") data: UpdateIdeaInput
) {
  return this.ideaService.updateIdea({ ...data, id: ideaId });
}
```

### Service
```ts
async updateIdea(data: UpdateIdeaInput & { id: string }) {
  const idea = await prismaClient.idea.findUnique({ where: { id: data.id } });
  if (!idea) throw new Error("Ideia não encontrada");

  return prismaClient.idea.update({
    where: { id: data.id },
    data: { title: data.title, description: data.description }
  });
}
```

Teste no Playground:
```graphql
mutation {
  updateIdea(ideaId: "abc123", data: { title: "Título atualizado!" }) {
    id
    title
    description
    author { name email }
  }
}
```
→ Atualiza apenas o que foi enviado, mantém o resto intacto

## Estado atual do Mindshare (resumo do que já funciona hoje)
- Cadastro e login com JWT + refresh token
- Rotas protegidas com middleware isAuth
- Usuário logado injetado automaticamente via @GQLUser()
- Criar ideia com autoria automática
- Buscar ideia + resolver autor completo via FieldResolver
- Atualizar ideia (apenas título e/ou descrição)

## Próximos passos (já anunciados ou óbvios)
- Listar ideias (públicas + minhas)
- Sistema de votos (upvote/downvote)
- Comentários com hierarquia ou respostas
- Refresh token endpoint
- Talvez paginação/infinite scroll com cursor

Tudo rodando liso, seguro e com código extremamente limpo graças ao TypeGraphQL + decorators!  
Mindshare já tem o core de ideias funcionando do começo ao fim.  
Bora pra próxima aula que agora vem votação e listagem!