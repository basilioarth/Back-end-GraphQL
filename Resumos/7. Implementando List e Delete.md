# Resumo da Aula 7 – Listagem + Deleção de Ideias (CRUD completo da Idea)

## 1. Query listIdeas (listagem completa)
```ts
@Query(() => [IdeaModel])           // ← array de IdeaModel
async listIdeas() {
  return this.ideaService.listIdeas();
}
```

Service:
```ts
async listIdeas() {
  return prismaClient.idea.findMany({
    include: { author: true }   // opcional, mas já vem graças ao field resolver
  });
}
```

Teste no Playground (com token):
```graphql
query {
  listIdeas {
    id
    title
    description
    author {
      id
      name
      email
    }
    createdAt
  }
}
```
→ Retorna todas as ideias com autor resolvido automaticamente pelo FieldResolver criado na aula anterior

## 2. Mutation deleteIdea (remoção segura)
```ts
@Mutation(() => Boolean)
@UseMiddleware(isAuth)
async deleteIdea(@Arg("ideaId") ideaId: string) {
  await this.ideaService.deleteIdea(ideaId);
  return true;
}
```

Service:
```ts
async deleteIdea(id: string) {
  const idea = await prismaClient.idea.findUnique({ where: { id } });
  if (!idea) throw new Error("Ideia não encontrada");

  await prismaClient.idea.delete({ where: { id } });
}
```

Teste no Playground:
```graphql
mutation {
  deleteIdea(ideaId: "clk123abc...")   # → true
}
```
→ Ideia removida com sucesso (cascade no Prisma cuida dos relacionamentos futuros)

## Estado atual do CRUD de Ideias – COMPLETO
| Operação       | Mutation/Query           | Protegida? | Autor automático? | Relacionamentos populados? |
|----------------|--------------------------|------------|-------------------|----------------------------|
| Create         | createIdea               | Yes        | Yes (@GQLUser)    | Yes (FieldResolver)        |
| Read (lista)   | listIdeas                | Yes        | –                 | Yes (FieldResolver)        |
| Read (única)   | (pode ser feita via list + filtro ou futura getIdea) | – | – | – |
| Update         | updateIdea               | Yes        | –                 | Yes                        |
| Delete         | deleteIdea               | Yes        | –                 | –                          |

Tudo funcionando perfeitamente com:
- Autenticação obrigatória
- Autor injetado automaticamente
- Relacionamento author resolvido sem N+1 (graças ao FieldResolver)
- Código limpo, tipado com TypeGraphQL

## Próximo passo anunciado pelo professor
Criar o modelo **Comment** (comentários nas ideias)  
Relacionar comentário → ideia → usuário  
Implementar:
- createComment
- listComments da ideia
- talvez respostas aninhadas (comentários filhos)

O Mindshare já tem o CRUD completo de ideias 100% funcional e seguro!  
Agora vamos para a camada de interação social (comentários e votos).  
Bora pra próxima aula!