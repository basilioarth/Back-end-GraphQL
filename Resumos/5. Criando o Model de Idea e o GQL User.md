# Resumo da Aula 5 – Criar Usuário por Convite + Modelo de Ideia + Decorator @GQLUser()

## 1. Ajustes no modelo User (tornar senha opcional)
- Prisma schema:
```prisma
password String? @default(null)
```
- Migration:
```bash
npx prisma migrate dev --name change-user-password-optional
```
- UserModel (GraphQL):
```ts
@Field(() => String, { nullable: true })
password?: string
```

## 2. Mutation createUser (convite interno)
- Input: `CreateUserInput` (apenas `name` e `email`)
- Service: verifica se e-mail já existe → cria usuário sem senha
- Mutation no `UserResolver`:
```ts
@Mutation(() => UserModel)
async createUser(@Arg("data") data: CreateUserInput) {
  return this.userService.createUser(data);
}
```

## 3. Modelo Idea no Prisma
```prisma
model Idea {
  id          String   @id @default(uuid())
  title       String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  authorId    String
  author      User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@map("ideas")
}
```
- Relacionamento bidirecional com User automaticamente criado
- Migration:
```bash
npx prisma migrate dev --name create-ideas
```

## 4. GraphQL – Model, Input e Service de Idea
- `IdeaModel` → `@ObjectType()` com campos + relação `@Field(() => UserModel)` author
- `CreateIdeaInput` → title (obrigatório) + description (opcional)
- `IdeaService.createIdea(data: CreateIdeaInput, authorId: string)`

## 5. Decorator @GQLUser() – o mais importante da aula
Pasta: `src/graphql/decorators/user.decorator.ts`

```ts
import { createParamDecorator } from "type-graphql";
import { GraphQLContext } from "../context";
import { prismaClient } from "../../prisma/client";

export const GQLUser = createParamDecorator<GraphQLContext>(async ({ context }) => {
  if (!context || !context.user) return null;

  try {
    const user = await prismaClient.user.findUnique({
      where: { id: context.user }
    });

    if (!user) throw new Error("Usuário não encontrado");

    return user;
  } catch (error) {
    console.log("Erro ao instanciar GQLUser:", error);
    return null;
  }
});
```

### Como usar no IdeaResolver
```ts
@Mutation(() => IdeaModel)
@UseMiddleware(isAuth)
async createIdea(
  @Arg("data") data: CreateIdeaInput,
  @GQLUser() user: User // ← automaticamente injetado e já buscado no banco
) {
  return this.ideaService.createIdea(data, user.id);
}
```

Benefícios:
- Não precisa mais passar `authorId` manualmente no input
- O resolver já recebe o usuário completo (ou null se não autenticado)
- Totalmente tipado e seguro

## Estado atual do projeto
- Usuário pode ser criado sem senha (convite)
- Ideia está modelada e relacionada ao autor
- Mutation `createIdea` quase pronta (só falta adicionar o decorator no resolver)
- Decorator @GQLUser() criado e funcional → agora qualquer mutation/query protegida pode receber o usuário logado automaticamente

## Próxima aula (prevista)
- Finalizar a mutation `createIdea` usando o @GQLUser()
- Criar queries para listar ideias (públicas + do usuário logado)
- Implementar sistema de votos e comentários

Tudo encaminhado para começar o core do Mindshare: cadastro de ideias com autoria automática e 100% protegido por autenticação!  
Bora pra próxima!